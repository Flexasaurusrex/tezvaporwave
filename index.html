<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Vaporwave Nature - Tezos NFT Mint</title>

  <!-- p5 for art -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <!-- Taquito core + BeaconWallet adapter (UMD builds) -->
  <script src="https://cdn.jsdelivr.net/npm/@taquito/taquito@17.3.2/dist/taquito.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@taquito/beacon-wallet@17.3.2/dist/taquito-beacon-wallet.umd.min.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family:'Orbitron',sans-serif;
      background:linear-gradient(180deg,#1a0033 0%,#330066 50%,#0d0d1a 100%);
      background-attachment:fixed; color:#fff; overflow-x:hidden; position:relative;
    }
    body::before {
      content:''; position:fixed; inset:0;
      background-image:
        linear-gradient(rgba(255,110,255,.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(1,205,254,.1) 1px, transparent 1px);
      background-size:50px 50px; animation:gridScroll 20s linear infinite;
      pointer-events:none; z-index:0;
    }
    @keyframes gridScroll { 0%{transform:perspective(500px) rotateX(60deg) translateY(0)} 100%{transform:perspective(500px) rotateX(60deg) translateY(50px)}}
    body::after {
      content:''; position:fixed; inset:0;
      background:repeating-linear-gradient(0deg, rgba(0,0,0,.15), rgba(0,0,0,.15) 1px, transparent 1px, transparent 2px);
      pointer-events:none; z-index:9999; animation:scanline 8s linear infinite;
    }
    @keyframes scanline { 0%{transform:translateY(0)} 100%{transform:translateY(10px)} }
    .container { max-width:1400px; margin:0 auto; padding:40px 20px; position:relative; z-index:1; }
    header { text-align:center; margin-bottom:60px; position:relative; }
    h1 {
      font-size:4rem; font-weight:900;
      background:linear-gradient(90deg,#FF6EFF,#00FFFF,#FF10F0);
      -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text;
      text-shadow:0 0 30px rgba(255,110,255,.5); margin-bottom:10px; letter-spacing:4px; animation:glitch 3s infinite;
    }
    @keyframes glitch {
      0%,100%{transform:translate(0)} 20%{transform:translate(-2px,2px)}
      40%{transform:translate(-2px,-2px)} 60%{transform:translate(2px,2px)} 80%{transform:translate(2px,-2px)}
    }
    .subtitle { font-size:1.2rem; color:#01CDFE; text-transform:uppercase; letter-spacing:6px; text-shadow:0 0 10px rgba(1,205,254,.8); }
    .main-grid { display:grid; grid-template-columns:1fr 1fr; gap:40px; margin-bottom:60px; }
    @media (max-width:968px){ .main-grid{ grid-template-columns:1fr; } }
    .card {
      background:rgba(0,0,0,.6); border:2px solid #FF6EFF; border-radius:0; padding:30px;
      box-shadow:0 0 20px rgba(255,110,255,.3), inset 0 0 20px rgba(1,205,254,.1);
      position:relative; overflow:hidden;
    }
    .card::before {
      content:''; position:absolute; top:-50%; left:-50%; width:200%; height:200%;
      background:linear-gradient(45deg, transparent, rgba(255,110,255,.1), transparent);
      transform:rotate(45deg); animation:shine 3s infinite;
    }
    @keyframes shine { 0%{transform:translate(-100%,-100%) rotate(45deg)} 100%{transform:translate(100%,100%) rotate(45deg)} }
    .card-title { font-size:1.8rem; color:#00FFFF; margin-bottom:20px; text-transform:uppercase; letter-spacing:3px; text-shadow:0 0 10px rgba(0,255,255,.8); }
    #canvas-container { width:100%; aspect-ratio:1; border:2px solid #01CDFE; box-shadow:0 0 30px rgba(1,205,254,.5); position:relative; overflow:hidden; }
    #canvas-container canvas { width:100% !important; height:100% !important; }
    .btn {
      background:linear-gradient(90deg,#FF6EFF,#01CDFE); border:none; color:#000; padding:15px 40px;
      font-family:'Orbitron',sans-serif; font-size:1rem; font-weight:700; text-transform:uppercase; letter-spacing:2px;
      cursor:pointer; position:relative; overflow:hidden; transition:all .3s; box-shadow:0 0 20px rgba(255,110,255,.5);
      width:100%; margin:10px 0;
    }
    .btn:hover { transform:translateY(-2px); box-shadow:0 0 30px rgba(255,110,255,.8); }
    .btn:active { transform:translateY(0); }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .btn-secondary { background:linear-gradient(90deg,#01CDFE,#B967FF); }
    .info-grid { display:grid; grid-template-columns:repeat(2,1fr); gap:15px; margin:20px 0; }
    .info-item { background:rgba(255,110,255,.1); border:1px solid #FF6EFF; padding:15px; text-align:center; }
    .info-label { font-size:.8rem; color:#01CDFE; text-transform:uppercase; letter-spacing:2px; margin-bottom:5px; }
    .info-value { font-size:1.5rem; color:#fff; font-weight:700; }
    .status { background:rgba(1,205,254,.1); border:1px solid #01CDFE; padding:15px; margin:15px 0; font-size:.9rem; text-align:center; }
    .status.error { background:rgba(255,110,255,.1); border-color:#FF6EFF; }
    .status.success { background:rgba(5,255,161,.1); border-color:#05FFA1; }
    .wallet-info { background:rgba(1,205,254,.05); border:1px solid #01CDFE; padding:10px; margin:10px 0; font-size:.85rem; word-break:break-all; }
    .features { display:grid; grid-template-columns:repeat(auto-fit,minmax(250px,1fr)); gap:20px; margin-top:40px; }
    .feature { background:rgba(0,0,0,.4); border:1px solid #B967FF; padding:20px; text-align:center; }
    .feature-icon { font-size:2rem; margin-bottom:10px; }
    .feature-title { color:#FF6EFF; font-size:1rem; margin-bottom:10px; text-transform:uppercase; letter-spacing:2px; }
    .feature-text { color:#01CDFE; font-size:.85rem; }
    footer { text-align:center; padding:40px 0; color:#01CDFE; font-size:.9rem; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>VAPORWAVE NATURE</h1>
      <p class="subtitle">Generative NFTs on Tezos</p>
    </header>

    <div class="main-grid">
      <!-- Art Preview -->
      <div class="card">
        <h2 class="card-title">Preview</h2>
        <div id="canvas-container"></div>
        <button class="btn btn-secondary" onclick="regenerate()">‚ü≥ Generate New Preview</button>
      </div>

      <!-- Minting Interface -->
      <div class="card">
        <h2 class="card-title">Mint Your NFT</h2>
        <div class="info-grid">
          <div class="info-item">
            <div class="info-label">Price</div>
            <div class="info-value">5 Íú©</div>
          </div>
          <div class="info-item">
            <div class="info-label">Minted</div>
            <div class="info-value"><span id="minted-count">0</span> / 100</div>
          </div>
        </div>

        <div id="wallet-status" class="status">Wallet not connected</div>

        <div id="wallet-info" class="wallet-info" style="display:none;">
          Connected: <span id="wallet-address"></span>
        </div>

        <button class="btn" id="connect-btn" onclick="connectWallet()" disabled>Loading Wallet...</button>
        <button class="btn" id="mint-btn" onclick="mint()" disabled>Mint for 5 Íú©</button>

        <div id="tx-status"></div>
      </div>
    </div>

    <!-- Features -->
    <div class="features">
      <div class="feature">
        <div class="feature-icon">üíé</div>
        <div class="feature-title">Crystals</div>
        <div class="feature-text">Geometric crystal formations with glowing vaporwave colors</div>
      </div>
      <div class="feature">
        <div class="feature-icon">‚õ∞Ô∏è</div>
        <div class="feature-title">Mountains</div>
        <div class="feature-text">Layered mountain ranges with procedural peaks</div>
      </div>
      <div class="feature">
        <div class="feature-icon">üåä</div>
        <div class="feature-title">Water</div>
        <div class="feature-text">Flowing water with shimmer and reflection effects</div>
      </div>
      <div class="feature">
        <div class="feature-icon">üé®</div>
        <div class="feature-title">Unique</div>
        <div class="feature-text">Each piece is algorithmically generated and one-of-a-kind</div>
      </div>
    </div>

    <footer><p>Vaporwave Nature ¬© 2025 | Built on Tezos</p></footer>
  </div>

  <!-- Vaporwave Art Engine (inline) -->
  <script>
    // Art generation code inline (unchanged)
    const vaporwaveSketch = function(p) {
      let tokenHash;
      let vaporwavePalettes = [
        ['#FF6EFF','#00FFFF','#FF10F0','#01CDFE','#B967FF'],
        ['#FE53BB','#08F7FE','#09FBD3','#F5D300','#FF006E'],
        ['#FF71CE','#01CDFE','#05FFA1','#B967FF','#FFFB96'],
        ['#FFB3FD','#2DE2E6','#F260AA','#261447','#FF9CEE'],
        ['#FF00FF','#00FF00','#FFFF00','#00FFFF','#FF0080'],
        ['#FF1493','#00FF7F','#FFD700','#FF4500','#7FFF00'],
        ['#FF69B4','#00CED1','#FF8C00','#ADFF2F','#FF1493'],
        ['#39FF14','#FF10F0','#FFFF00','#FF006E','#00F5FF'],
        ['#CCFF00','#FF0090','#00FFFF','#FFAA00','#FF006E'],
        ['#BFFF00','#FF1493','#00F5FF','#FF4500','#7FFF00'],
        ['#8A2BE2','#FF1493','#00CED1','#FF6347','#9400D3'],
        ['#4B0082','#FF00FF','#00FA9A','#FF6347','#8B008B'],
        ['#6A0DAD','#FF69B4','#00FFFF','#FF4500','#9932CC'],
        ['#FF6B6B','#FFA500','#FFD700','#FF1493','#FF69B4'],
        ['#FF4500','#FF8C00','#FFD700','#FF1493','#FFA07A'],
        ['#0000FF','#00CED1','#4169E1','#1E90FF','#87CEEB'],
        ['#006994','#00D4FF','#0096FF','#00F5FF','#40E0D0'],
        ['#FF0000','#FF4500','#00FFFF','#0000FF','#FF1493'],
        ['#DC143C','#FF6347','#00CED1','#4169E1','#FF69B4'],
        ['#00FF00','#39FF14','#CCFF00','#7FFF00','#ADFF2F'],
        ['#7FFF00','#00FF7F','#00FA9A','#98FB98','#90EE90'],
        ['#9400D3','#8A2BE2','#BA55D3','#DA70D6','#EE82EE'],
        ['#8B008B','#9932CC','#9370DB','#DDA0DD','#FF00FF'],
        ['#FFD700','#FFA500','#FF8C00','#FF6347','#FF4500'],
        ['#FFDF00','#FFBF00','#FFB700','#FFA500','#FF8C00']
      ];

      let mountains=[], crystals=[], waves=[], palette, bgGradient, gridAlpha, hasSun, hasMoon, hasStars, gridStyle, sunColor, moonColor;

      p.setup = function() {
        const canvas = p.createCanvas(800,800);
        canvas.parent('canvas-container');
        p.noLoop();
        if (!tokenHash) tokenHash = generateRandomHash();
        initializeFromHash(tokenHash);
        drawGenerativeArt();
        console.log('‚úì Art generated successfully');
      }

      function generateRandomHash(){
        let hash='0x'; for(let i=0;i<64;i++){ hash += p.floor(p.random(16)).toString(16); } return hash;
      }

      function initializeFromHash(hash){
        let seed=0; for(let i=2;i<hash.length;i++){ seed += parseInt(hash[i],16); }
        p.randomSeed(seed); p.noiseSeed(seed);
        let paletteIndex = p.floor(p.map(parseInt(hash.substr(2,4),16),0,65536,0,vaporwavePalettes.length));
        palette = vaporwavePalettes[paletteIndex];

        let bgStyle = parseInt(hash.substr(4,1),16)%4;
        if(bgStyle===0){
          bgGradient={ top:p.color(parseInt(hash.substr(6,2),16),parseInt(hash.substr(8,2),16),parseInt(hash.substr(10,2),16)+100),
                       bottom:p.color(parseInt(hash.substr(12,2),16)+50,parseInt(hash.substr(14,2),16),parseInt(hash.substr(16,2),16)+50) };
        } else if (bgStyle===1){
          bgGradient={ top:p.color(palette[0]), bottom:p.color(palette[2]) };
        } else if (bgStyle===2){
          bgGradient={ top:p.color(10,5,30), bottom:p.color(50,20,80) };
        } else {
          bgGradient={ top:p.color(255,100,150), bottom:p.color(100,50,150) };
        }

        gridAlpha = p.map(parseInt(hash.substr(18,2),16),0,255,10,50);
        gridStyle = parseInt(hash.substr(19,1),16)%3;
        hasSun = parseInt(hash.substr(20,1),16)>7;
        hasMoon = parseInt(hash.substr(21,1),16)>9;
        hasStars = parseInt(hash.substr(22,1),16)>5;
        sunColor = palette[parseInt(hash.substr(23,1),16)%palette.length];
        moonColor = palette[parseInt(hash.substr(24,1),16)%palette.length];

        mountains=[];
        const numMountainLayers = p.floor(p.map(parseInt(hash.substr(26,2),16),0,255,2,7));
        for(let i=0;i<numMountainLayers;i++){
          let mountainStyle = parseInt(hash.substr(28+i,1),16)%3;
          mountains.push({
            y:p.map(i,0,numMountainLayers,p.height*0.3,p.height*0.85),
            peaks:p.floor(p.map(parseInt(hash.substr(30+i*2,2),16),0,255,3,12)),
            color:palette[i%palette.length],
            alpha:p.map(i,0,numMountainLayers-1,200,60),
            roughness:p.map(parseInt(hash.substr(36+i,2),16),0,255,0.2,1.2),
            style:mountainStyle,
            hasOutline:parseInt(hash.substr(38+i,1),16)>8
          });
        }

        crystals=[];
        const numCrystals = p.floor(p.map(parseInt(hash.substr(44,2),16),0,255,3,15));
        for(let i=0;i<numCrystals;i++){
          let o=46+i*5, t=parseInt(hash.substr(o,1),16)%4;
          crystals.push({
            x:p.map(parseInt(hash.substr(o+1,2),16),0,255,p.width*0.05,p.width*0.95),
            y:p.map(parseInt(hash.substr(o+3,2),16),0,255,p.height*0.2,p.height*0.75),
            size:p.map(parseInt(hash.substr(o+5,2),16),0,255,20,150),
            rotation:p.map(parseInt(hash.substr(o+7,2),16),0,255,-p.PI/4,p.PI/4),
            faces:p.floor(p.map(parseInt(hash.substr(o+9,1),16),0,15,3,9)),
            color:palette[i%palette.length],
            wireframe:parseInt(hash.substr(o+10,1),16)>8,
            type:t,
            glow:parseInt(hash.substr(o+11,1),16)>7,
            innerColor:palette[(i+2)%palette.length]
          });
        }

        waves=[];
        const numWaves = p.floor(p.map(parseInt(hash.substr(60,1),16),0,15,5,12));
        for(let i=0;i<numWaves;i++){
          waves.push({
            y:p.height*0.7 + i * p.map(numWaves,5,12,20,10),
            amplitude:p.map(i,0,numWaves,20,3),
            frequency:p.map(i,0,numWaves,0.008,0.025),
            phase:p.random(p.TWO_PI),
            color:palette[i%palette.length],
            alpha:p.map(i,0,numWaves,120,20),
            style:parseInt(hash.substr(61+i,1),16)%2
          });
        }
      }

      function drawGenerativeArt(){
        drawGradient();
        if(hasSun) drawSun();
        if(hasMoon) drawMoon();
        if(hasStars) drawStars();
        drawGrid(); drawWater(); drawMountains(); drawCrystals(); drawScanlines(); drawVignette();
        p.noFill(); p.strokeWeight(3); p.stroke(palette[0]); p.rect(10,10,p.width-20,p.height-20);
      }

      function drawGradient(){ for(let y=0;y<p.height;y++){ let inter=p.map(y,0,p.height,0,1); let c=p.lerpColor(bgGradient.top,bgGradient.bottom,inter); p.stroke(c); p.line(0,y,p.width,y);} }
      function drawSun(){ let x=p.width*.8,y=p.height*.2,s=p.random(80,150); p.drawingContext.shadowBlur=50; p.drawingContext.shadowColor=sunColor; p.fill(sunColor); p.noStroke(); p.ellipse(x,y,s,s); p.stroke(sunColor); p.strokeWeight(3); for(let i=0;i<12;i++){ let a=(p.TWO_PI/12)*i; let x1=x+p.cos(a)*(s/2+10), y1=y+p.sin(a)*(s/2+10), x2=x+p.cos(a)*(s/2+30), y2=y+p.sin(a)*(s/2+30); p.line(x1,y1,x2,y2);} p.drawingContext.shadowBlur=0; }
      function drawMoon(){ let x=p.width*.2,y=p.height*.15,s=p.random(60,120); p.drawingContext.shadowBlur=40; p.drawingContext.shadowColor=moonColor; p.fill(moonColor); p.noStroke(); p.ellipse(x,y,s,s); p.fill(0,0,0,30); for(let i=0;i<5;i++){ let cx=x+p.random(-s/3,s/3), cy=y+p.random(-s/3,s/3), cs=p.random(s/8,s/4); p.ellipse(cx,cy,cs,cs);} p.drawingContext.shadowBlur=0; }
      function drawStars(){ p.noStroke(); for(let i=0;i<50;i++){ let x=p.random(p.width), y=p.random(p.height*.6), size=p.random(1,4), col=palette[p.floor(p.random(palette.length))]; p.fill(col); if(p.random()>0.7){ p.push(); p.translate(x,y); p.beginShape(); for(let j=0;j<5;j++){ let ang=(p.TWO_PI/5)*j - p.PI/2, r=j%2===0? size*2 : size; p.vertex(p.cos(ang)*r,p.sin(ang)*r);} p.endShape(p.CLOSE); p.pop(); } else { p.ellipse(x,y,size,size);} } }
      function drawGrid(){
        p.stroke(255,255,255,gridAlpha); p.strokeWeight(1);
        let gridSize = gridStyle===1?25: (gridStyle===2?60:40);
        for(let y=p.height*.6;y<p.height;y+=gridSize){ let fade=p.map(y,p.height*.6,p.height,1,.3); p.stroke(255,255,255,gridAlpha*fade); p.line(0,y,p.width,y); }
        for(let x=0;x<p.width;x+=gridSize){ p.stroke(255,255,255,gridAlpha*.5); p.line(x,p.height*.6,x,p.height); }
      }
      function drawMountains(){
        for(let m of mountains){
          p.fill(m.color); p.stroke(m.color); p.strokeWeight(2); p.beginShape(); p.vertex(0,p.height);
          let step=p.width/m.peaks/2;
          for(let x=0;x<=p.width;x+=step){
            let y;
            if(m.style===0){ let n=p.noise(x*.01*m.roughness,m.y*.01); y=p.map(n,0,1,m.y,m.y-p.height*.35); }
            else if(m.style===1){ let n=p.noise(x*.02*m.roughness,m.y*.01); y=p.map(n,0,1,m.y,m.y-p.height*.4); y+=p.random(-20,20); }
            else { let w=p.sin(x*.02)*30; let n=p.noise(x*.008*m.roughness,m.y*.01); y=p.map(n,0,1,m.y,m.y-p.height*.3)+w; }
            p.vertex(x,y);
          }
          p.vertex(p.width,p.height); p.endShape(p.CLOSE);

          if(m.hasOutline){
            p.stroke(255,255,255,80); p.strokeWeight(2); p.noFill(); p.beginShape();
            for(let x=0;x<=p.width;x+=step){
              let y;
              if(m.style===0){ let n=p.noise(x*.01*m.roughness,m.y*.01); y=p.map(n,0,1,m.y,m.y-p.height*.35); }
              else if(m.style===1){ let n=p.noise(x*.02*m.roughness,m.y*.01); y=p.map(n,0,1,m.y,m.y-p.height*.4); }
              else { let w=p.sin(x*.02)*30; let n=p.noise(x*.008*m.roughness,m.y*.01); y=p.map(n,0,1,m.y,m.y-p.height*.3)+w; }
              p.vertex(x,y-3);
            }
            p.endShape();
          }
        }
      }
      function drawCrystals(){
        for(let c of crystals){
          p.push(); p.translate(c.x,c.y); p.rotate(c.rotation);
          if(c.wireframe){ p.noFill(); p.stroke(c.color); p.strokeWeight(3); }
          else { p.fill(c.color); p.stroke(255,255,255,150); p.strokeWeight(2); }
          if(c.type===0){ p.beginShape(); for(let i=0;i<c.faces;i++){ let a=p.TWO_PI*i/c.faces, r=c.size; p.vertex(p.cos(a)*r,p.sin(a)*r);} p.endShape(p.CLOSE); }
          else if(c.type===1){ p.beginShape(); for(let i=0;i<c.faces*2;i++){ let a=p.TWO_PI*i/(c.faces*2), r= i%2===0? c.size : c.size*.5; p.vertex(p.cos(a)*r,p.sin(a)*r);} p.endShape(p.CLOSE); }
          else if(c.type===2){ p.beginShape(); p.vertex(0,-c.size); p.vertex(c.size*.6,0); p.vertex(0,c.size); p.vertex(-c.size*.6,0); p.endShape(p.CLOSE); }
          else { p.beginShape();
            p.vertex(c.size*.5,-c.size*.8); p.vertex(c.size*.8,-c.size*.3); p.vertex(c.size*.8,c.size*.3);
            p.vertex(c.size*.5,c.size*.8); p.vertex(-c.size*.5,c.size*.8); p.vertex(-c.size*.8,c.size*.3);
            p.vertex(-c.size*.8,-c.size*.3); p.vertex(-c.size*.5,-c.size*.8); p.endShape(CLOSE);
          }
          if(!c.wireframe){
            p.fill(c.innerColor); p.noStroke();
            if(c.type===0){ p.beginShape(); for(let i=0;i<c.faces;i++){ let a=p.TWO_PI*i/c.faces, r=c.size*.4; p.vertex(p.cos(a)*r,p.sin(a)*r);} p.endShape(p.CLOSE); }
            else if(c.type===2){ p.beginShape(); p.vertex(0,-c.size*.5); p.vertex(c.size*.3,0); p.vertex(0,c.size*.5); p.vertex(-c.size*.3,0); p.endShape(p.CLOSE); }
          }
          if(c.glow){ p.drawingContext.shadowBlur=30; p.drawingContext.shadowColor=c.color; }
          p.pop(); p.drawingContext.shadowBlur=0;
        }
      }
      function drawWater(){
        p.noStroke();
        for(let w of waves){
          let col=p.color(w.color); col.setAlpha(w.alpha); p.fill(col);
          p.beginShape(); p.vertex(0,p.height);
          if(w.style===0){ for(let x=0;x<=p.width;x+=5){ let y=w.y + p.sin(x*w.frequency + w.phase)*w.amplitude; p.vertex(x,y);} }
          else { for(let x=0;x<=p.width;x+=10){ let y=w.y + p.sin(x*w.frequency + w.phase)*w.amplitude + p.random(-5,5); p.vertex(x,y);} }
          p.vertex(p.width,p.height); p.endShape(p.CLOSE);
        }
        for(let i=0;i<30;i++){
          let x=p.random(p.width), y=p.random(p.height*.7,p.height), c=palette[p.floor(p.random(palette.length))];
          p.fill(c); p.noStroke();
          if(p.random()>0.7){ p.ellipse(x,y,p.random(8,15),p.random(2,4)); } else { p.ellipse(x,y,p.random(2,8),p.random(2,8)); }
        }
      }
      function drawScanlines(){ p.stroke(0,0,0,30); p.strokeWeight(1); for(let y=0;y<p.height;y+=4){ p.line(0,y,p.width,y);} }
      function drawVignette(){
        p.drawingContext.globalCompositeOperation='multiply';
        let g=p.drawingContext.createRadialGradient(p.width/2,p.height/2,0,p.width/2,p.height/2,p.width*.7);
        g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(0,0,0,.7)');
        p.drawingContext.fillStyle=g; p.drawingContext.fillRect(0,0,p.width,p.height);
        p.drawingContext.globalCompositeOperation='source-over';
      }
      window.regenerateArt = function(){
        console.log('Regenerating art...'); tokenHash=generateRandomHash();
        mountains=[]; crystals=[]; waves=[]; hasSun=false; hasMoon=false; hasStars=false;
        initializeFromHash(tokenHash); p.clear(); drawGenerativeArt();
      }
    };
    new p5(vaporwaveSketch);
    function regenerate(){ if(window.regenerateArt){ window.regenerateArt(); } }
  </script>

  <!-- Tezos Wallet Integration (fixed) -->
  <script>
    // --- Config ---
    const CONTRACT_ADDRESS = "KT1..."; // <-- set your contract address
    const NETWORK_TYPE = "mainnet";    // "ghostnet" for testnet
    const RPC_URL = NETWORK_TYPE === "mainnet"
      ? "https://mainnet.api.tez.ie"
      : "https://rpc.ghostnet.teztnets.com";

    let Tezos;
    let wallet;          // BeaconWallet adapter for Taquito
    let userAddress;

    // Wait for UMD globals
    function waitForDependencies() {
      return new Promise((resolve, reject) => {
        let attempts = 0;
        const max = 50; // ~5s
        const iv = setInterval(() => {
          attempts++;
          const hasTaquito = typeof window.taquito !== 'undefined';
          const hasBeaconWallet = typeof window.taquito_beacon_wallet !== 'undefined';
          if (hasTaquito && hasBeaconWallet) {
            clearInterval(iv);
            resolve();
          } else if (attempts >= max) {
            clearInterval(iv);
            reject(new Error("Taquito/BeaconWallet failed to load. Check CDN script tags."));
          }
        }, 100);
      });
    }

    async function init() {
      try {
        await waitForDependencies();

        // UMD globals:
        //  - taquito.TezosToolkit
        //  - taquito_beacon_wallet.BeaconWallet
        Tezos = new taquito.TezosToolkit(RPC_URL);

        wallet = new taquito_beacon_wallet.BeaconWallet({
          name: "Vaporwave Nature",
          preferredNetwork: NETWORK_TYPE,
          appUrl: "https://tezvaporwave.vercel.app",
          iconUrl: "https://tezvaporwave.vercel.app/favicon.ico"
        });

        Tezos.setWalletProvider(wallet);

        // Restore session if available
        const pkh = await wallet.getPKH().catch(() => null);
        if (pkh) {
          userAddress = pkh;
          updateWalletUI(true);
          updateStatus("Ready! Wallet reconnected.", "success");
        } else {
          const connectBtn = document.getElementById('connect-btn');
          connectBtn.disabled = false;
          connectBtn.textContent = "Connect Wallet";
          updateStatus("Ready! Connect your Tezos wallet to mint.", "status");
        }

        // Optional stats load
        loadContractStats().catch(() => {});

      } catch (err) {
        console.error(err);
        updateStatus("Failed to load wallet features. Please refresh.", "error");
      }
    }

    async function connectWallet() {
      try {
        updateStatus("Opening wallet‚Ä¶", "status");

        await wallet.requestPermissions({
          network: { type: NETWORK_TYPE, rpcUrl: RPC_URL }
        });

        userAddress = await wallet.getPKH();
        updateWalletUI(true);
        updateStatus("Wallet connected! üéâ", "success");
      } catch (error) {
        console.error(error);
        const msg = String(error?.message || "");
        if (msg.includes("Aborted")) {
          updateStatus("Connection cancelled by user", "error");
        } else {
          updateStatus("Connection failed: " + (error.message || "Unknown error"), "error");
        }
      }
    }

    async function mint() {
      if (!userAddress) {
        updateStatus("Please connect your wallet first", "error");
        return;
      }
      if (CONTRACT_ADDRESS === "KT1...") {
        updateStatus("Contract not deployed yet", "error");
        return;
      }

      try {
        updateStatus("Preparing transaction‚Ä¶", "status");
        document.getElementById('mint-btn').disabled = true;

        // Use Wallet API for signing ops
        const contract = await Tezos.wallet.at(CONTRACT_ADDRESS);

        updateStatus("Please confirm in your wallet‚Ä¶", "status");

        // Adjust entrypoint/params to your contract
        const op = await contract.methods.mint().send({ amount: 5, mutez: false });

        updateStatus("Submitted! Waiting for confirmation‚Ä¶", "status");
        await op.confirmation();

        updateStatus("Mint successful! üéâ", "success");
        await loadContractStats();
      } catch (error) {
        console.error("Error minting:", error);
        updateStatus("Mint failed: " + (error.message || "Unknown error"), "error");
      } finally {
        document.getElementById('mint-btn').disabled = false;
      }
    }

    async function loadContractStats() {
      try {
        if (CONTRACT_ADDRESS === "KT1...") return;
        const c = await Tezos.contract.at(CONTRACT_ADDRESS);
        const storage = await c.storage();
        // Adjust this to your storage schema
        document.getElementById('minted-count').textContent = storage.next_token_id?.toString?.() ?? "?";
      } catch (e) {
        document.getElementById('minted-count').textContent = "?";
      }
    }

    function updateWalletUI(connected) {
      const connectBtn = document.getElementById('connect-btn');
      const mintBtn = document.getElementById('mint-btn');
      const walletInfo = document.getElementById('wallet-info');
      const walletAddress = document.getElementById('wallet-address');

      if (connected) {
        connectBtn.textContent = "‚úì Connected";
        connectBtn.disabled = true;
        connectBtn.style.opacity = "0.7";
        mintBtn.disabled = false;
        walletInfo.style.display = 'block';
        walletAddress.textContent = userAddress.slice(0,8) + "..." + userAddress.slice(-6);
        updateStatus("Ready to mint!", "success");
      } else {
        connectBtn.textContent = "Connect Wallet";
        connectBtn.disabled = false;
        connectBtn.style.opacity = "1";
        mintBtn.disabled = true;
        walletInfo.style.display = 'none';
        updateStatus("Connect your wallet to mint", "status");
      }
    }

    function updateStatus(message, type = "status") {
      const el = document.getElementById('wallet-status');
      el.textContent = message;
      el.className = `status ${type}`;
    }

    window.addEventListener('load', init);
  </script>
</body>
</html>
